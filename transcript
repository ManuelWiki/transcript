#include <utility>
#include <vector>
#include <functional>

template<class T>
class Predicate{
    std::function<bool(T)> eval;
public:
    constexpr Predicate(std::function<bool(T)> e)
    : eval(e)
    {}

    constexpr Predicate(T v)
    : eval([&](T a){ return a == v; })
    {}
};

template<class T>
constexpr Predicate<T> N(std::function<bool(T)> e, unsigned n = 1)
{
    return Predicate<T>(e);
}

template<class T>
constexpr Predicate<T> N(T v, unsigned n = 1)
{
    return Predicate<T>(v);
}

template <class T, class Target>
class Grammar{
    using AssocFunction = std::function<Target(T)>;

    std::vector<std::vector<Predicate<T> > > patterns;
    std::vector<AssocFunction> assoc;
public:
    constexpr Grammar(std::vector<std::pair<std::vector<Predicate<T>>, AssocFunction>> patts)
    {
        for (auto [vp, a] : patts)
        {
            patterns.push_back(vp);
            assoc.push_back(a);
        }
    }

    unsigned countPatterns()
    {
        return patterns.size();
    }
};