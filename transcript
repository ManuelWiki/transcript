#include <string>

enum class TokenType { Normal, End, Opt1, Opt2, N, ZeroOrMore, Optional };

class Token {
    char value;
    unsigned number = 0;
    TokenType type;

    Token *child;
    Token *next;

    friend Token NToken(unsigned);
    friend Token EndToken();
    friend Token ZeroOrMore();
    friend Token Optional();
    friend Token Option1();
    friend Token Option2();

    Token (TokenType t, unsigned n = 0)
    :type(t), number(n)
    {}

public:
    Token (char v)
    : value(v)
    {}

    bool isNormal() { return type == TokenType::Normal; }
    bool isN() { return type == TokenType::N; }
    bool isEnd() { return type == TokenType::End; }
    bool isZeroOrMore() { return type == TokenType::ZeroOrMore; }
    bool isOptional() { return type == TokenType::Optional; }
    bool isOpt1() { return type == TokenType::Opt1; }
    bool isOpt2() { return type == TokenType::Opt2; }

    bool tolerates()
    {
        return isZeroOrMore() || isOptional() || isOpt1;
    }

    bool isGroup()
    {
        return isN() || isZeroOrMore() || isOptional() || isOpt1() || isOpt2();
    }

    bool isLeaf() { return child == nullptr && next == nullptr; }

    unsigned getNumber() { return number; }
};

Token NToken(unsigned n)
{
    return Token(TokenType::N, n);
}
Token EndToken()
{
    return Token(TokenType::End);
}
Token ZeroOrMore() /* (*) */
{
    return Token(TokenType::ZeroOrMore); 
}
Token Optional() /* (?) */
{
    return Token(TokenType::Optional); 
}
Token Option1()
{
    return Token(TokenType::Opt1);
}
Token Option2()
{
    return Token(TokenType::Opt2);
}

template <class AssociatedType>
class Pattern {
    Token *root;
    AssociatedType assocValue;
    
    class NestingLevel {
        Token *token;
        NestingLevel *parent;
        std::string::const_iterator inputPosition;
        unsigned count = 0;

    public:
        NestingLevel(Token *t, std::string::const_iterator i, NestingLevel *p)
        : token(t), inputPosition(i), parent(p)
        {}

        Token *getToken() { return token; }
        NestingLevel *getParent() { return parent; }
        unsigned getCount() { return count; }
        std::string::const_iterator getInputPosition() { return inputPosition; }

        void incrementCount() { count++; }

        bool isFull() { return count == token->getNumber; }
    };

    class NestingStack {
        NestingLevel *top = nullptr;

    public:
        bool handle(Token *&patternPos, std::string::const_iterator inputPos)
        {
            const NestingLevel *nearest = nullptr;
            NestingLevel *curr = top;
            while (curr != nullptr && nearest == nullptr)
            {
                if (curr->getToken()->tolerates())
                    nearest = curr;
                curr = curr->getParent();
            }
            // nearest = the highest Nesting Level that tolerates

            if (nearest == nullptr)
                return false;
            
            inputPos = nearest->getInputPosition();
            patternPos = nearest->getToken()->getNext();

            return true;
        }

        bool isEmpty() { return top == nullptr; }

        void addLevel(Token *t, std::string::const_iterator i)
        {
            top = new NestingLevel(t, i, top);
        }

        void pop()
        {
            // DANGER: do not call this on empty stacks
            top = top->getParent();
            // todo: I think I should free the memory occupied by top's last value
        }
    }

    bool matches(std::string::const_iterator &bg, std::string::const_iterator &end)
    {
        // stop when (a) curr isLeaf and (b) stack is empty and (c) curr char != end
        // (a ^ b) = ~(~a | ~b) = A; ~A = (~a | ~b) = curr is not Leaf or stack is not empty
        Token *curr = root;
        std::string::const_iterator curr_char = bg;
        NestingStack stack;
        /*
        is Normal?
            applies?
                curr token = curr_token.next, increment curr char
            else
                !stack.handle()? return false
        is Group?
            stack.add(currtoken, ...), curr_token = curr_token.inner, DON'T increment curr char

        is Leaf?
            top is opt1?
                curr_token = stack.getTop().getToken() + 2, increment curr char
            else, top is full?
                curr_token = stack.getTop().getToken() + 1, stack.pop(), increment curr char
            else
                count++, curr_token = stack.getTop().getToken() + 1, increment curr char
        */

        return true;
    }
};