#include <vector>
#include <functional>
#include <utility>

enum class TokenType { 
    none, // To use in the stack in the transpile function. Uses no members (else than type)
    eval, // Normal Token to be evaluated. Uses eval
    loop, // Loop token for multiple predicates. Uses a, b and c
    options // OR token. Uses a and b
};

template <class T>
class Token{
protected:
    using Pred = std::function<bool(T)>;

    unsigned a, b, c;
    TokenType type;
    Pred eval;
public:
    Token(T value)
    : eval([=](T v){ return v == value; }), type(TokenType::eval)
    {}

    Token(Pred eval)
    : eval(eval), type(TokenType::eval)
    {}

    constexpr Token(TokenType type, unsigned a, unsigned b, unsigned c = 0)
    : type(type), a(a), b(b), c(c)
    {}
};

template <class Src, class Target>
class AssocFn { // Associated Function
    std::function<Target(std::vector<Src>)> fn;

public:
    AssocFn(std::function<Target(std::vector<Src>)> f)
    : fn(f)
    {}

    AssocFn(std::function<Target(Src)> f)
    : fn([&](std::vector<Src> s){
        return f(s.back());
    })
    {}

    // For debugging
    Target call(std::vector<Src> p)
    {
        return fn(p); 
    }
};

template <class Src>
class TokenList{

    std::vector<Token<Src>> preds;

    // Overload for Src
    static void append(TokenList& app_to, Src last);

    template <class... Args>
    static void append(TokenList& app_to, Src first, Args... rest);

    // Overload for std::function
    template <class... Args>
    static void append(TokenList& app_to, std::function<bool(Src)> first, Args... rest);

    static void append(TokenList& app_to, std::function<bool(Src)> last);

    // Overload for TokenList
    template <class... Args>
    static void append(TokenList& app_to, TokenList first, Args... rest);

    static void append(TokenList& app_to, TokenList last);

    // Overload for Token
    template <class... Args>
    static void append(TokenList& app_to, Token<Src> first, Args... rest);

    static void append(TokenList& app_to, Token<Src> last);

public:
    //fw first argument is std::function
    template<class... Args>
    TokenList(std::function<bool(Src)> first, Args... rest)
    {
        append(*this, first);
        append(*this, rest...);
    }
    
    //fw first element is Src
    template<class... Args>
    TokenList(Src first, Args... rest)
    {
        append(*this, first);
        append(*this, rest...);
    }

    //fw first element is another TokenList
    template <class... Args>
    TokenList(TokenList<Src> first, Args... rest)
    {
        append(*this, first);
        append(*this, rest...);
    }

    //fw first argument is Token
    template<class... Args>
    TokenList(Token<Src> first, Args... rest)
    {
        append(*this, first);
        append(*this, rest...);
    }

    // For debugging
    unsigned size();
};

// Overload for Token
template<class Src>
void TokenList<Src>::append(TokenList& app_to, Token<Src> last)
{
    app_to.preds.emplace_back(last);
}

template <class Src> template <class... Args>
void TokenList<Src>::append(TokenList& app_to, Token<Src> first, Args... rest)
{
    app_to.preds.emplace_back(first);
    app_to.append(app_to, rest...);
}

// Overload for Src
template<class Src>
void TokenList<Src>::append(TokenList& app_to, Src last)
{
    app_to.preds.emplace_back(Token<Src>(last));
}

template <class Src> template <class... Args>
void TokenList<Src>::append(TokenList& app_to, Src first, Args... rest)
{
    app_to.preds.emplace_back(Token<Src>(first));
    app_to.append(app_to, rest...);
}

// Overload for Pred
template <class Src> template <class... Args>
void TokenList<Src>::append(TokenList& app_to, std::function<bool(Src)> first, Args... rest)
{
    app_to.preds.emplace_back(Token<Src>(first));
    app_to.append(app_to, rest...);
}

template <class Src>
void TokenList<Src>::append(TokenList& app_to, std::function<bool(Src)> last)
{
    app_to.preds.emplace_back(Token<Src>(last));
}

// Overload for TokenList
template <class Src> template <class... Args>
void TokenList<Src>::append(TokenList& app_to, TokenList<Src> first, Args... rest)
{
    for(auto &p : first.preds){
        app_to.preds.emplace_back(p);
    }
    append(app_to, rest...);
}

template <class Src> 
void TokenList<Src>::append(TokenList& app_to, TokenList<Src> last)
{
    for(auto &p : last.preds){
        app_to.preds.emplace_back(p);
    }
}

// For debugging
template <class Src>
unsigned TokenList<Src>::size()
{
    return preds.size();
}

template <class Src>
TokenList<Src> operator| (TokenList<Src> a, TokenList<Src> b)
{
    unsigned len_a = a.size();
    unsigned len_b = b.size();
    return TokenList<Src>(Token<Src>(TokenType::options, len_a, len_b), a, b);
}

template <class Src, class Target>
class Pattern {
    TokenList<Src> tokens;
    AssocFn<Src, Target> fn;
public:
    Pattern(TokenList<Src> tkns, AssocFn<Src, Target> f)
    : tokens(tkns), fn(f)
    {}
};

template <class Src, class Target>
class Syntax {
    std::vector<Pattern<Src, Target>> patts;

public:
    Syntax(std::initializer_list<Pattern<Src, Target>> patterns)
    {
        for (auto &p : patterns)
        {
            patts.emplace_back(p);
        }
    }

    // For debugging 
    unsigned countPatterns() {
        return patts.size();
    }
};