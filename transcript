#include <vector>
#include <functional>

template <class T>
struct PredBuilder{
private:
    using Pred = std::function<bool(T)>;

    Pred eval;
    unsigned jumpSrc = 1;
    unsigned jumpPattern = 1;
public:
    PredBuilder(T value, unsigned jumpSrc = 1, unsigned jumpPattern = 1)
    : eval([=](T v){ return v == value; }), jumpSrc(jumpSrc), jumpPattern(jumpPattern)
    {}

    PredBuilder(Pred eval, unsigned jumpSrc = 1, unsigned jumpPattern = 1)
    : eval(eval), jumpSrc(jumpSrc), jumpPattern(jumpPattern)
    {}
}; 

template <class Src>
class Builder{ // Pattern Builder

    std::vector<PredBuilder<Src>> preds;

    // Overload for Src
    static void append(Builder& app_to, Src last);

    template <class... Args>
    static void append(Builder& app_to, Src first, Args... rest);

    // Overload for Pred
    template <class... Args>
    static void append(Builder& app_to, std::function<bool(Src)> first, Args... rest);

    static void append(Builder& app_to, std::function<bool(Src)> last);

    // Overload for Builder
    template <class... Args>
    static void append(Builder& app_to, Builder first, Args... rest);

    static void append(Builder& app_to, Builder last);

public:
    //fw first argument is Pred
    template<class... Args>
    Builder(std::function<bool(Src)> first, Args... rest)
    {
        append(*this, first);
        append(*this, rest...);
    }
    
    //fw first element is Src
    template<class... Args>
    Builder(Src first, Args... rest)
    {
        append(*this, first);
        append(*this, rest...);
    }

    //fw first element is another Builder
    template <class... Args>
    Builder(Builder<Src> first, Args... rest)
    {
        append(*this, first);
        append(*this, rest...);
    }

    // For debugging
    unsigned countPreds();
};

// Overload for Src
template<class Src>
void Builder<Src>::append(Builder& app_to, Src last)
{
    app_to.preds.emplace_back(PredBuilder<Src>(last));
}

template <class Src> template <class... Args>
void Builder<Src>::append(Builder& app_to, Src first, Args... rest)
{
    app_to.preds.emplace_back(PredBuilder<Src>(first));
    app_to.append(app_to, rest...);
}

// Overload for Pred
template <class Src> template <class... Args>
void Builder<Src>::append(Builder& app_to, std::function<bool(Src)> first, Args... rest)
{
    app_to.preds.emplace_back(PredBuilder<Src>(first));
    app_to.append(app_to, rest...);
}

template <class Src>
void Builder<Src>::append(Builder& app_to, std::function<bool(Src)> last)
{
    app_to.preds.emplace_back(PredBuilder<Src>(last));
}

// Overload for Builder
template <class Src> template <class... Args>
void Builder<Src>::append(Builder& app_to, Builder<Src> first, Args... rest)
{
    for(auto &p : first.preds){
        app_to.preds.emplace_back(p);
    }
    append(app_to, rest...);
}

template <class Src> 
void Builder<Src>::append(Builder& app_to, Builder<Src> last)
{
    for(auto &p : last.preds){
        app_to.preds.emplace_back(p);
    }
}

// For debugging
template <class Src>
unsigned Builder<Src>::countPreds()
{
    return preds.size();
}